<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wentao&#39; Blog</title>
  
  
  <link href="https://timesea054.github.io/atom.xml" rel="self"/>
  
  <link href="https://timesea054.github.io/"/>
  <updated>2022-08-20T13:20:59.573Z</updated>
  <id>https://timesea054.github.io/</id>
  
  <author>
    <name>Wentao An</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>发点牢骚-1</title>
    <link href="https://timesea054.github.io/2022/08/20/%E7%89%A2%E9%AA%9A-1/"/>
    <id>https://timesea054.github.io/2022/08/20/%E7%89%A2%E9%AA%9A-1/</id>
    <published>2022-08-20T12:32:38.633Z</published>
    <updated>2022-08-20T13:20:59.573Z</updated>
    
    <content type="html"><![CDATA[<p>今天是开学前的最后一个周六，一时兴起去爬了香山。爬完香山回来，和老朋友史文轩吃了个饭。我有预料到，今天爬香山非常非常累，大概率回宿舍之后会犯困，忧郁的情绪也会接踵而来。果然不出我所料，它如约而至，不过这次它不再像之前那样没有源头，而是被一个又一个的炸弹触发。</p><p>昨天晚上闲来无事刷小红，无意间就刷到了自己的学长小豪，昨天晚上和他聊了一会。今天我又点进他的主页看了一下，看了看他发的动态，没想到在他动态的评论中发现了自己之前喜欢的那个学长，他小红账号原来的名字我早已经记不清了，但他现在已经改了名字了，叫路路路nlp，大概率是保研到做NLP的组里面了吧，也希望他以后越来越好吧。我记得原来我刚刚注册小红账号的时候，想找到他的账号然后拉黑来着，没有找到，或许他在那个时候就已经改了名字了吧。点进他的主页，他还是那么可爱，和原来一样。追他的时候是大二上学期，整个过程持续了差不多一个月。当时我是完全被他迷住了，也尝试过追他，最后还是不了了之了。每次想到他我都会想起自己当舔狗的痛苦回忆哈哈哈。当时我放弃追他，主要原因是他不喜欢我，另外一个原因是我发现我们确实不是一个世界的人，也不够合拍，即使强行把我们放在一起，也不可能走到最后。让我死心的直接原因是我被程序设计的大作业折磨得死去活来，整个人那几天就处于抑郁的状态，追他也没有什么正面的反馈，就很干脆地放弃了。</p><p>另外一件让我感到抑郁的炸弹是关于出国访学的事情。今天跟史文轩聊起来，他说访学就应该大三下学期去啊，正好也耽误不了保研。回来我看了一下本科部发布的那个去新加坡国立大学访学的通知，上面写着访学时间是1月到5月，正好和保研错开。我想要不要这个把自己原定大四上学期出国的计划改掉，搞到大三下？这时候问题和困难就出现了：之前打算是大四去访学，就没有办护照，难不成又要回家办护照？这可把我愁坏了，这个时间点家里有疫情，回去麻烦还不说，回去就回不来了。护照办理应该也是支持异地的，身份证都可以异地，为啥护照就不行(生气脸)。明天打算去石景山这边的派出所问一下。但突然想到大四去访学的话，是8月份到12月份，也耽误不了保研，保研夏令营到7月底截至。emmm似乎大四去也还可以啊。这个心结突然就被解开了QAQ。而且要是大三下去访学的话，没法和家里人一起过年了，多少有点可惜。</p><p>今天的牢骚就先发到这里吧。</p><p>自己对生活的记录真的就是流水账，用英语中的一个词描述就是plain。可能这就是理工男吧。羡慕读书多，有文采的人，他们写出的文字就像魔法，可以把你带到他们的内心世界。如果有下辈子，我想当一个文科生。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天是开学前的最后一个周六，一时兴起去爬了香山。爬完香山回来，和老朋友史文轩吃了个饭。我有预料到，今天爬香山非常非常累，大概率回宿舍之后会犯困，忧郁的情绪也会接踵而来。果然不出我所料，它如约而至，不过这次它不再像之前那样没有源头，而是被一个又一个的炸弹触发。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>玉泉路：一路向北</title>
    <link href="https://timesea054.github.io/2022/08/19/%E7%8E%89%E6%B3%89%E8%B7%AF-%E4%B8%80%E8%B7%AF%E5%90%91%E5%8C%97/"/>
    <id>https://timesea054.github.io/2022/08/19/%E7%8E%89%E6%B3%89%E8%B7%AF-%E4%B8%80%E8%B7%AF%E5%90%91%E5%8C%97/</id>
    <published>2022-08-19T11:07:02.089Z</published>
    <updated>2022-08-19T12:18:35.239Z</updated>
    
    <content type="html"><![CDATA[<p>虽然说我已经来北京两年了，但是对这个城市我还是感到很陌生。许许多多有名的景点我都还没有去过。这个暑假留在北京，也弥补了自己的一些遗憾。从7月份回到北京的这一个月里，我先去了国贸看了看著名的央视”大裤衩”，又和坤哥去了钟楼鼓楼和天坛，再和阿辉去了颐和园。</p><p>不用说整个北京了，其实学校周边我都没探索完。目前我只知道，石景山路和复兴路是长安街的延申，往东便是长安街和天安门，往西是石景山和门头沟。东边最远我到过四惠，西边最远我到过长安街的尽头：一座不知名的山。沿玉泉路一直向南可以到达丰台区，尽头是京港澳高速。沿玉泉路向北是田村，田村再向北我便不知道了。</p><p>昨天晚上的时候，刷Instagram看到了一个人的帖子，里面又很多在北京五环外的荒郊野岭拍的照片。看完我就心动了，想着第二天也去看一看，但突然想到自己连着三天没有做核酸了，明天肯定是没法坐地铁去五环外了，可行的出行方式只有骑共享单车。那倒不如沿着玉泉路一路向北骑行，看看它会延申到哪里，说不定还能直通中关村。</p><p>今天早上11点半从被窝里面爬出来，去食堂吃了个饭，回到宿舍看蒋炎岩老师的操作系统课。看完一节后，我便开始了今天的行动。从学校刚出来的时候，天气非常好，有蓝天，也有大片的云彩，而且这一大片云彩就刚好在自己的头顶上，完美地挡住了烈日，极度舒适。</p><img src="https://s3.bmp.ovh/imgs/2022/08/19/0466c16877e58ee9.jpg" style="zoom: 50%;" /><p>沿着玉泉路向北走，到达云层的边界，阳光开始变得强烈：</p><img src="https://s3.bmp.ovh/imgs/2022/08/19/d6904e495314f13c.jpg" style="zoom:50%;" /><p>再往北走，云层消失，天空变得湛蓝，我被放在烈日下煎烤：</p><img src="https://s3.bmp.ovh/imgs/2022/08/19/6c449a17d32a84d9.jpg" style="zoom:50%;" /><p>继续向北能看见铁路道口。这东西我原来只在考科目一和科目四刷题的时候看到过，没想到它还真的出现在了我的生活中：</p><img src="https://s3.bmp.ovh/imgs/2022/08/19/1640e44173c39320.jpg" style="zoom:50%;" /><img src="https://s3.bmp.ovh/imgs/2022/08/19/19585eb31118e392.jpg" style="zoom:50%;" /><p>再向北可以看到北京郊区的群山。幸亏玉泉路(再向北叫旱阳路)沿途高大的树木不少，不然自己真的就要被烤熟了：</p><img src="https://s1.ax1x.com/2022/08/19/vsiRNq.jpg" alt="vsiRNq.jpg" style="zoom:50%;" /><img src="https://s1.ax1x.com/2022/08/19/vsi7DJ.jpg" alt="vsi7DJ.jpg" style="zoom:50%;" /><p>沿途还能看到李大钊烈士陵园。在这附近向北的路消失了，只能继续向西骑行。没想到这么荒的地方还能看到一个地铁站，叫万安，在西郊线上。</p><img src="https://s1.ax1x.com/2022/08/19/vsFrPx.jpg" alt="vsFrPx.jpg" style="zoom:50%;" /><img src="https://s1.ax1x.com/2022/08/19/vsFgMD.jpg" alt="vsFgMD.jpg" style="zoom:50%;" /><p>这个西郊线让我想起我的第一次面基经历。我当时只知道小蓝这个软件，就一直用着它。一天，一个信工所的学长刷到了我，就开始找我聊天，我觉得这个人也蛮不错的，也一直跟他聊着。聊了差不多有一个星期之后，他提起要面基。面基的前一天晚上我还幻想这个人会不会是一个寸头或者其他短发类型的帅哥，没想到见了面发现他的发型是我最讨厌的蘑菇头，而且很胖，是那种虚胖。啊，他为啥这么丑！这可让我太失望了。之后我们决定去爬香山，当时坐的就是这个西郊线。他爬到半山腰就爬不动了，而且在路上经常要我停下来等等他或者停一下休息休息。我想起来他在小蓝上的简介，说自己是熊。这是熊吗？这不就是典型的猪吗哈哈哈(当然我那个时候才刚入圈，并不知道熊和猪是什么，这是我后来才知道的)。总之这一天的体验就是相当的不愉快，尽管是他中午请我吃的饭(那家餐厅具体我也忘记叫什么了，那天吃的应该是猪大骨)。后来我删除了他的所有联系方式，他还在小蓝上发消息问我怎么回事，我当然是已读不回了。后来想想自己的这一套骚操作确实欠妥，毕竟他也是一个还不错的人呐。只能怪自己情商太低，对为人处世了解的道理了解得还是不够多。</p><p>从这有点让人难堪的回忆中回来。到了地铁站附近，再也没有什么树木能遮挡阳光了，自己整个人处于太阳的暴晒中。原本还想到山下面看看，最后实在撑不住了，打道回府。回去的时候还发现了指向颐和园的路标。原来这个地方离颐和园还挺近的，在往东一点就到了。从颐和园再往东就是中关村了。</p><p><img src="https://s1.ax1x.com/2022/08/19/vskSJ0.jpg" alt="vskSJ0.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;虽然说我已经来北京两年了，但是对这个城市我还是感到很陌生。许许多多有名的景点我都还没有去过。这个暑假留在北京，也弥补了自己的一些遗憾。从7月份回到北京的这一个月里，我先去了国贸看了看著名的央视”大裤衩”，又和坤哥去了钟楼鼓楼和天坛，再和阿辉去了颐和园。&lt;/p&gt;
&lt;p&gt;不用说</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>xv6:调试第一个用户进程</title>
    <link href="https://timesea054.github.io/2022/08/18/xv6-%E8%B0%83%E8%AF%95%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B/"/>
    <id>https://timesea054.github.io/2022/08/18/xv6-%E8%B0%83%E8%AF%95%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B/</id>
    <published>2022-08-18T13:08:04.219Z</published>
    <updated>2022-08-18T15:32:40.599Z</updated>
    
    <content type="html"><![CDATA[<p>本文是南京大学蒋炎岩老师操作系统课调试xv6代码的复现与扩展，相关课程参考：<a href="https://www.bilibili.com/video/BV1DY4y1a7YD?spm_id_from=333.999.0.0">Xv6 代码导读 (调试工具配置; 调试系统调用执行)</a>.</p><p>在配置好调试xv6内核调试的环境之后，便可以开始调试内核代码。关于xv6内核的调试可以参考下面这篇文章：<a href="https://hitsz-lab.gitee.io/os-labs-2021/gdb/">https://hitsz-lab.gitee.io/os-labs-2021/gdb/</a>.</p><p>调试开始时，程序在入口<code>kernel/main.c</code>处挂起。继续进行调试，内核会做一些初始化的工作，随后来到初始化第一个用户进程的函数<code>userinit()</code>：</p><img src="https://s3.bmp.ovh/imgs/2022/08/18/6b573deb9dbd0ec5.png" style="zoom:67%;" /><p>进入这个函数之后，在<code>kernel/proc.c</code>中，我们可以看到第一个用户进程的代码的二进制形式：</p><pre><code>&#x2F;&#x2F; a user program that calls exec(&quot;&#x2F;init&quot;)&#x2F;&#x2F; od -t xC initcodeuchar initcode[] &#x3D; {  0x17, 0x05, 0x00, 0x00, 0x13, 0x05, 0x45, 0x02,  0x97, 0x05, 0x00, 0x00, 0x93, 0x85, 0x35, 0x02,  0x93, 0x08, 0x70, 0x00, 0x73, 0x00, 0x00, 0x00,  0x93, 0x08, 0x20, 0x00, 0x73, 0x00, 0x00, 0x00,  0xef, 0xf0, 0x9f, 0xff, 0x2f, 0x69, 0x6e, 0x69,  0x74, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00};</code></pre><p>二进制代码的RISC-V反汇编在<code>initcode.S</code> 中：</p><pre><code># Initial process that execs &#x2F;init.# This code runs in user space.#include &quot;syscall.h&quot;# exec(init, argv).globl startstart:        la a0, init        la a1, argv        li a7, SYS_exec        ecall# for(;;) exit();exit:        li a7, SYS_exit        ecall        jal exit# char init[] &#x3D; &quot;&#x2F;init\0&quot;;init:  .string &quot;&#x2F;init\0&quot;# char *argv[] &#x3D; { init, 0 };.p2align 2argv:  .long init  .long 0</code></pre><p>之后退出vscode，使用命令行gdb调试<code>initcode</code> 的汇编代码。在<code>x86-64</code>架构的PC上使用普通的gdb无法正常调试RISCV-64架构的二进制文件<code>kernel</code>，所以我们需要换用RISC-V指令集的调试器。我是用<code>gdb-multiarch</code>调试内核的。不知道为什么，配置文件<code>.gdbinit</code>没有自动加载到gdb中，在我将其中的配置逐一输入到gdb后，开始调试，程序会停在操作系统内核的入口处：</p><pre><code>(gdb) target remote 127.0.0.1:26000Remote debugging using 127.0.0.1:26000warning: No executable has been specified and target does not supportdetermining executable automatically.  Try using the &quot;file&quot; command.0x0000000000001000 in ?? ()</code></pre><p>接着我们在地址0处打一个断点(用户进程的第一条指令在其地址空间的0地址处)。执行continue，程序在<code>initcode</code>的第一条指令处挂起。执行<code>si</code>，至<code>ecall</code>指令处：</p><pre><code>Breakpoint 1, 0x0000000000000000 in ?? ()&#x3D;&gt; 0x0000000000000000:  17 05 00 00     auipc   a0,0x0(gdb) b *0Note: breakpoint 1 also set at pc 0x0.Breakpoint 2 at 0x0(gdb) x&#x2F;10i 0&#x3D;&gt; 0x0: auipc   a0,0x0   0x4: addi    a0,a0,36   0x8: auipc   a1,0x0   0xc: addi    a1,a1,35   0x10:        li      a7,7   0x14:        ecall   0x18:        li      a7,2   0x1c:        ecall   0x20:        jal     ra,0x18   0x24:        0x696e692f</code></pre><p>在继续执行ecall指令之前，我们需要了解RISC-V的trap机制。下面的内容来自xv6的手册：</p><blockquote><p>Here’s an outline of the most important registers:</p><ul><li><p><strong>stvec</strong>: The kernel writes the address of its trap handler here; the RISC-V jumps to the address in stvec to handle a trap.</p></li><li><p><strong>sepc</strong>: When a trap occurs, RISC-V saves the program counter here (since the pc is then overwritten with the value in stvec). The sret (return from trap) instruction copies sepc to the pc. The kernel can write sepc to control where sret goes.</p></li><li><p><strong>scause</strong>: RISC-V puts a number here that describes the reason for the trap.</p></li><li><p><strong>sscratch</strong>: The kernel places a value here that comes in handy at the very start of a trap handler.</p></li><li><p><strong>sstatus</strong>: The SIE bit in sstatus controls whether device interrupts are enabled. If the kernel clears SIE, the RISC-V will defer device interrupts until the kernel sets SIE. The SPP bit indicates whether a trap came from user mode or supervisor mode, and controls to what mode sret returns.</p></li></ul><p>When it needs to force a trap, the RISC-V hardware does the following for all trap types (other than timer interrupts):</p><ol><li>If the trap is a device interrupt, and the sstatus SIE bit is clear, don’t do any of the following.</li><li>Disable interrupts by clearing the SIE bit in <strong>sstatus</strong></li><li>Copy the <strong>pc</strong> to <strong>sepc</strong>.</li><li>Save the current mode (user or supervisor) in the SPP bit in <strong>sstatus</strong></li><li>Set <strong>scause</strong> to reflect the trap’s cause (ecall: 8)</li><li>Set the mode to supervisor.</li><li>Copy <strong>stvec</strong> to the <strong>pc</strong>.</li></ol></blockquote><p>终端处理程序的入口地址已经存在了<code>stvec</code>寄存器中，在终端输入<code>x $stvec</code>，gdb提示</p><pre><code>0x3ffffff000:        Cannot access memory at address 0x3ffffff000</code></pre><p>在<code>qemu</code>中使用<code>info mem</code>查看内存信息：</p><pre><code>(qemu) info memvaddr            paddr            size             attr---------------- ---------------- ---------------- -------0000000000000000 0000000087f73000 0000000000001000 rwxu-a-0000003fffffe000 0000000087f77000 0000000000001000 rw---a-0000003ffffff000 0000000080007000 0000000000001000 r-x--a-</code></pre><p>虚拟地址对应的<code>0x3ffffff000</code>处的内存的<code>attr</code>中不包含字母u，说明此处内存是用户不可访问的，是操作系统内核中断处理程序的入口处。</p><p>现在我们验证一下手册中关于中断处理的操作系统行为。在执行ecall指令前，打印以下寄存器的信息</p><pre><code>(gdb) x $pc&#x3D;&gt; 0x14:        ecall(gdb) x $stvec   0x3ffffff000:        Cannot access memory at address 0x3ffffff000(gdb) x $sepc   0x0: auipc   a0,0x0</code></pre><p>执行ecall指令后：</p><pre><code>Breakpoint 3, 0x0000003ffffff000 in ?? ()&#x3D;&gt; 0x0000003ffffff000:  73 15 05 14     csrrw   a0,sscratch,a0(gdb) x $pc&#x3D;&gt; 0x3ffffff000:        csrrw   a0,sscratch,a0(gdb) x $stvec&#x3D;&gt; 0x3ffffff000:        csrrw   a0,sscratch,a0(gdb) x $sepc   0x14:        Cannot access memory at address 0x14(gdb) p $scause$2 &#x3D; 8</code></pre><p>手册中规定的行为果然被复现了：<code>stvec</code>中的值被拷贝到了<code>pc</code>中，而<code>pc</code>的值被保存到了<code>sepc</code>中。同时<code>scause</code>寄存器的值也被设置成了8. 现在使用gdb tui查看反汇编，可以看到反汇编的内容就是<code>trampoline.S</code>中的汇编代码：</p><p><img src="https://s1.328888.xyz/2022/08/18/3Mw3h.png"></p><p>这部分代码做的便是保存寄存器现场的工作，对进程做一个snapshot，方便在中断结束后恢复。sd指令便是将寄存器的值保存到内存中一块叫trapframe的区域，不同寄存器有不同的偏移量。这样保存的好处是操作系统内核可以很方便的访问这些进程，修改他们的寄存器等。在保存寄存器现场后，程序会跳转到<code>usertrap()</code>函数的入口。</p><pre><code># jump to usertrap(), which does not returnjr t0</code></pre><p>继续进行调试，来到函数<code>usertrap</code>的入口处，截取<code>usertrap</code>的部分代码如下：</p><pre><code>voidusertrap(void){  &#x2F;&#x2F; ...  struct proc *p &#x3D; myproc();  if(r_scause() &#x3D;&#x3D; 8){    &#x2F;&#x2F; system call    if(p-&gt;killed)      exit(-1);        &#x2F;&#x2F; sepc points to the ecall instruction,    &#x2F;&#x2F; but we want to return to the next instruction.    p-&gt;trapframe-&gt;epc +&#x3D; 4;        &#x2F;&#x2F; an interrupt will change sstatus &amp;c registers,    &#x2F;&#x2F; so don&#39;t enable until done with those registers.    intr_on();        syscall();  } else {      &#x2F;&#x2F;...  }  &#x2F;&#x2F;...  usertrapret();}</code></pre><p>进入<code>usertrap</code>之后，系统还要做一些保存寄存器的工作，同时改变一些寄存器的值。之后打开中断并执行<code>syscall</code>。<code>syscall</code>的实现和xv6: lab2会放到另外一篇博客中去介绍。之后进入中断返回程序<code>usertrapret</code>。该函数除了在做完一些必要的工作之后，需要恢复寄存器现场：</p><pre><code>voidusertrapret(void) {  &#x2F;&#x2F; ...other works  &#x2F;&#x2F; jump to trampoline.S at the top of memory, which   &#x2F;&#x2F; switches to the user page table, restores user registers,  &#x2F;&#x2F; and switches to user mode with sret.  uint64 fn &#x3D; TRAMPOLINE + (userret - trampoline);  ((void (*)(uint64,uint64))fn)(TRAPFRAME, satp);}</code></pre><p>在上面的这段代码中，fn便是<code>trampoline.S</code>中<code>userret</code>函数的地址，对其进行强制类型转换为函数指针即可调用该函数。这段汇编代码执行一系列的load指令，将<code>tramframe</code>中的寄存器快照恢复到寄存器中，并执行<code>sret</code>指令，将sepc寄存器的值(0)赋给pc。</p><p>所以为什么sepc的值会变成0呢？刚才我们执行了一个系统调用，a7寄存器的值为7，对应<code>sys_exec</code>，执行了一个<code>exec</code>系统调用，相当于重置了这一个进程的状态机。这个进程再继续执行时，自然要从虚拟地址为0处的指令开始执行，所以sepc的值会被提前设置为0，并被拷贝到pc中。更改sepc值的函数或是指令我没有找到，我不确定是不是<code>sret</code>指令的上一条<code>csrrw</code>更改的它的值。这个坑以后再来填。</p><p>使用gdb追踪<code>sret</code>后的指令执行：</p><pre><code>0x0000000000000000:  01 11   addi    sp,sp,-320x0000000000000002:  06 ec   sd      ra,24(sp)0x0000000000000004:  22 e8   sd      s0,16(sp)0x0000000000000006:  26 e4   sd      s1,8(sp)0x0000000000000008:  4a e0   sd      s2,0(sp)0x000000000000000a:  00 10   addi    s0,sp,320x000000000000000c:  89 45   li      a1,20x000000000000000e:  17 15 00 00     auipc   a0,0x10x0000000000000012:  13 05 a5 88     addi    a0,a0,-19100x0000000000000016:  97 00 00 00     auipc   ra,0x00x000000000000001a:  e7 80 80 39     jalr    920(ra)0x00000000000003ae:  bd 48   li      a7,150x00000000000003b0:  73 00 00 00     ecall</code></pre><p>这一段指令执行让我感到非常的困惑。我没有在xv6的汇编代码中没有找到上面的片段，而如果这段代码是C程序的反汇编，那么gdb应该会标识这段代码在哪一个函数中。这让我百思不得其解。ecall之后便是重复地跳转到<code>trampoline.S</code>中执行中断处理程序。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文是南京大学蒋炎岩老师操作系统课调试xv6代码的复现与扩展，相关课程参考：&lt;a href=&quot;https://www.bilibili.com/video/BV1DY4y1a7YD?spm_id_from=333.999.0.0&quot;&gt;Xv6 代码导读 (调试工具配置; 调试系</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>小镇做题家：序章</title>
    <link href="https://timesea054.github.io/2022/08/16/%E5%B0%8F%E9%95%87%E5%81%9A%E9%A2%98%E5%AE%B6-%E5%BA%8F%E7%AB%A0/"/>
    <id>https://timesea054.github.io/2022/08/16/%E5%B0%8F%E9%95%87%E5%81%9A%E9%A2%98%E5%AE%B6-%E5%BA%8F%E7%AB%A0/</id>
    <published>2022-08-16T13:29:57.334Z</published>
    <updated>2022-08-16T14:50:10.634Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>它最早诞生于豆瓣，大致指的是那些出身于农村或者小城镇的学子，埋头苦读，通过高考实现了人生的进阶，却缺乏一定的视野和社会资源，即使靠多年苦读，也很难追平原生家庭和出身带来的差距。而“小镇”，则成了普通家庭或者寒门的代名词。– 中国数字时代</p></blockquote><p>最初见到这个词是刚上大学的时候，也是这个词开始爆火的时候、和这个词类似的还有“985废物”等等。关于这个词的含义，上面已经解释得比较清楚了。感觉这个词，就是为我量身定做的：出生在高考大省，农村户口，家庭条件算是村里面比较差的，除了会学习会做题一无所长，没有什么爱好，情商低，眼界窄……到了大学之后，自己不再只是一个只会学习和刷题的机器，我开始思考自己人生的方方面面。我的脑袋中经常会有一些碎片性的想法，这些想法有些是对过去的回忆，有些是对未来的计划，有些是对当下的思考，有些是一些感叹……在这里开一个坑，记录下自己这些琐碎的思维片段，当5年，10年，20年过去之后，自己再看到这些文字，不知道是会感到后悔、叹惋还是滑稽。</p><p>小镇就像是一个深深的井，高考考到北京，就像是把我这只青蛙从黑漆漆的井底提溜出来，看看外面的阳光和风景。习惯了黑暗的青蛙，在看到外面光怪陆离的景象后，自然会觉得不适应。至于我会不会被生活再踢回井里，便是N年之后的事了。刚来到大学的时候，感觉自己就是个废人：学习学不好，什么爱好也没有，什么才艺也没有，觉得自己生活在这个学校的底层。当时特别喜欢韩国的一个纪录片，叫《学习的背叛》。当时的我深深沉浸在这部纪录片传达出的绝望和痛苦之中，不能自拔，原因也很简单：我觉得自己被学习背叛了。在过去的中学时代，自己没日没夜的学习，刷题，为了就是考一个好的大学，以后有好的前途。后来我发现是我的想法太天真了，不过这对于一个18岁刚步入大学的孩子来说，倒也正常。事实上，不是学习背叛了我，而是我对它的期望太高，它的能力只能够带我飞出井里，带我到外面转一圈，我却将逆天改命的愿望寄托于它。</p><p>当然，我不满足于自己的出身。事实上，没有人满足于自己的出身，因为人的欲望是无穷无尽的：出生在农村的想：要是自己出生在城市就好了；出生在城市的想，要是我父母不是这样普通，而是公司老总或者政府大官就好了。尽管我偶尔会抱怨，会难过，但我很少将这些消极的情绪传达给我的父母，或者在心里埋怨过他们。因为我知道，他们已经给了我他们能给我最好的一切，我在脑海中也搜寻不到他们亏待我的记忆，倒是我亏待他们的记忆有不少。毕竟，出身是无法选择的，对吗？</p><p>在大学的这几年中，我一直想摆脱这个词带给我的一系列影响。我的室友有一个是二线城市长大的，他曾经公开表达过自己对小镇做题家的鄙视，当时这让我感到非常的气愤，但我也无法反驳：一是我的嘴实在是太笨，不会吵架，二是他说的都是事实。我只能将愤怒强压在心里，让时间去消解它。但这个词的含义，在我身上的烙印，我想这辈子都不会去掉，后来也慢慢接受了这个事实，和高中同学聊天的时候自己也经常用这个称呼。我就是小镇做题家。</p><p>想想自己的小学同学、初中同学，他们之中很多因为成绩不好，去了技校，早早的开始工作，甚至已经打算娶妻生子(因为年龄的限制，没有办法领证)。我听了他们的故事之后，连连摇头，心中感慨：这绝对不是我想要的生活。(这里也不必用那套类似政治正确的言论来约束我：在中国，在大多数人眼中，这样的工作和生活就是失败的)。自己靠着会做题这一项本领，在高考中杀出重围，给了自己能够选择自己生活的能力，也还不错。</p><p>前几天在Instagram上和一个朋友聊天，聊到说我自己从小到大都是老师和家长眼中的乖乖宝，特别的听话，因此也特别遗憾自己过去因为听话失去了尝试很多其他东西的机会。但是他觉得，既然我从小到打一路都是这么走过来的，就说明自己适合走这样的路，也不必羡慕别人的生活。生活就像水流一样，顺着它走就好了，也不必非要改变他的流向。当你觉得你的生活让你感到不舒服的时候，再尝试去改变它。确实如此。</p><p>开始写这篇文章的时候，自己真的是一个字也憋不出来，到后来越来越顺，文字就像流水一样流淌出来。从Typora的计数来看，我到这里已经写了1600多个字了。以此作为这个栏目的序章，再好不过了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;它最早诞生于豆瓣，大致指的是那些出身于农村或者小城镇的学子，埋头苦读，通过高考实现了人生的进阶，却缺乏一定的视野和社会资源，即使靠多年苦读，也很难追平原生家庭和出身带来的差距。而“小镇”，则成了普通家庭或者寒门的代名词。	– 中国数字时代&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>基于React与Golang的简易外卖派单模拟系统</title>
    <link href="https://timesea054.github.io/2022/08/15/%E5%9F%BA%E4%BA%8EReact%E4%B8%8EGolang%E7%9A%84%E7%AE%80%E6%98%93%E5%A4%96%E5%8D%96%E6%B4%BE%E5%8D%95%E6%A8%A1%E6%8B%9F%E7%B3%BB%E7%BB%9F/"/>
    <id>https://timesea054.github.io/2022/08/15/%E5%9F%BA%E4%BA%8EReact%E4%B8%8EGolang%E7%9A%84%E7%AE%80%E6%98%93%E5%A4%96%E5%8D%96%E6%B4%BE%E5%8D%95%E6%A8%A1%E6%8B%9F%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-08-15T15:22:34.415Z</published>
    <updated>2022-08-16T13:26:24.444Z</updated>
    
    <content type="html"><![CDATA[<p>仓库地址: <a href="https://github.com/TimeSea05/food-order-distr-sim">https://github.com/TimeSea05/food-order-distr-sim</a></p><p>这个项目是尤老师在大二下学期分配给我的，但大二下课程实在太重(自己还补修了大一的两门课)，于是就拖到了暑假来完成。这个项目是我第一次接触后端开发，上手比较困难。最开始的时候我理解错了老师的意思，做了一个简易的<a href="https://github.com/TimeSea05/food-order-distr-client">客户端</a>出来(应该是骑手的客户端)，但老师想让我做的是一个模拟：模拟订单生成，然后后端根据自己的算法、前端和数据库中的数据，来给外卖员派单。一边学习并发(感谢NJU 蒋炎岩老师的<a href="http://jyywiki.cn/OS/2022/">公开课</a>)，一边做这个项目，在一个星期之后，终于整了一个像样的demo出来。</p><h2 id="1-总体架构"><a href="#1-总体架构" class="headerlink" title="1. 总体架构"></a>1. 总体架构</h2><p><img src="https://raw.githubusercontent.com/TimeSea05/food-order-distr-sim/master/img/procedures.svg" alt="procedures.svg"></p><p>前端模拟订单的生成，将生成的订单信息传送到后端监听端口。后端监听端口在接收到订单信息后，将订单信息存入数据库中。在后端有4个Goroutine(Go语言自带的协程)从数据库中取出订单，并将其放入缓冲区。同时又有32个Goroutine来处理订单，在处理订单时不停的改变外卖员(courier)的信息。</p><h2 id="2-前端"><a href="#2-前端" class="headerlink" title="2. 前端"></a>2. 前端</h2><p>前端用泊松分布来模拟订单的生成。由于泊松分布是二项分布的极限情况，所以我们在将时间间隔调整的非常小的情况下，可以利用二项分布来近似泊松分布。</p><p><code>src/App.js</code>中利用<code>rsuite</code>组件库搭建了一个简单的表格，在表格中输入模拟的时间<code>simTime</code>和这段时间内订单的平均值<code>orderNum</code>，即可开始模拟。</p><p>模拟订单生成的代码在<code>src/Poisson-Simulation.js</code>中。利用二项分布生成订单的思路如下：设置每一次实验的间隔为<code>25ms</code>，利用给定的模拟时间来求出实验的次数<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.009ex" height="1.545ex" role="img" focusable="false" viewBox="0 -683 888 683" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D441" xlink:href="#MJX-1-TEX-I-1D441"></use></g></g></g></svg></mjx-container>。利用给定的平均值<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.027ex;" xmlns="http://www.w3.org/2000/svg" width="1.319ex" height="1.597ex" role="img" focusable="false" viewBox="0 -694 583 706" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D706" d="M166 673Q166 685 183 694H202Q292 691 316 644Q322 629 373 486T474 207T524 67Q531 47 537 34T546 15T551 6T555 2T556 -2T550 -11H482Q457 3 450 18T399 152L354 277L340 262Q327 246 293 207T236 141Q211 112 174 69Q123 9 111 -1T83 -12Q47 -12 47 20Q47 37 61 52T199 187Q229 216 266 252T321 306L338 322Q338 323 288 462T234 612Q214 657 183 657Q166 657 166 673Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D706" xlink:href="#MJX-1-TEX-I-1D706"></use></g></g></g></svg></mjx-container>来求出概率值<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.614ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3807.6 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path><path id="MJX-1-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-1-TEX-I-1D706" d="M166 673Q166 685 183 694H202Q292 691 316 644Q322 629 373 486T474 207T524 67Q531 47 537 34T546 15T551 6T555 2T556 -2T550 -11H482Q457 3 450 18T399 152L354 277L340 262Q327 246 293 207T236 141Q211 112 174 69Q123 9 111 -1T83 -12Q47 -12 47 20Q47 37 61 52T199 187Q229 216 266 252T321 306L338 322Q338 323 288 462T234 612Q214 657 183 657Q166 657 166 673Z"></path><path id="MJX-1-TEX-N-2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path><path id="MJX-1-TEX-I-1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D45D" xlink:href="#MJX-1-TEX-I-1D45D"></use></g><g data-mml-node="mo" transform="translate(780.8,0)"><use data-c="3D" xlink:href="#MJX-1-TEX-N-3D"></use></g><g data-mml-node="mi" transform="translate(1836.6,0)"><use data-c="1D706" xlink:href="#MJX-1-TEX-I-1D706"></use></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2419.6,0)"><g data-mml-node="mo"><use data-c="2F" xlink:href="#MJX-1-TEX-N-2F"></use></g></g><g data-mml-node="mi" transform="translate(2919.6,0)"><use data-c="1D441" xlink:href="#MJX-1-TEX-I-1D441"></use></g></g></g></svg></mjx-container></p><p>随后在每一次实验中，使用<code>Math.random()</code>获取一个<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="5.28ex" height="1.557ex" role="img" focusable="false" viewBox="0 -666 2333.6 688" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-N-30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path><path id="MJX-1-TEX-N-223C" d="M55 166Q55 241 101 304T222 367Q260 367 296 349T362 304T421 252T484 208T554 189Q616 189 655 236T694 338Q694 350 698 358T708 367Q722 367 722 334Q722 260 677 197T562 134H554Q517 134 481 152T414 196T355 248T292 293T223 311Q179 311 145 286Q109 257 96 218T80 156T69 133Q55 133 55 166Z"></path><path id="MJX-1-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><use data-c="30" xlink:href="#MJX-1-TEX-N-30"></use></g><g data-mml-node="mo" transform="translate(777.8,0)"><use data-c="223C" xlink:href="#MJX-1-TEX-N-223C"></use></g><g data-mml-node="mn" transform="translate(1833.6,0)"><use data-c="31" xlink:href="#MJX-1-TEX-N-31"></use></g></g></g></svg></mjx-container>之间的浮点数，如果这个数小于<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="1.138ex" height="1.439ex" role="img" focusable="false" viewBox="0 -442 503 636" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D45D" xlink:href="#MJX-1-TEX-I-1D45D"></use></g></g></g></svg></mjx-container>，那么就向后端发送请求，否则不执行任何操作。</p><pre><code>const sendOrderReq &#x3D; () &#x3D;&gt; {  if (Math.random() &lt; prob) {    console.log(&#39;Send a food order&#39;)    fetch(&#39;http:&#x2F;&#x2F;localhost:8000&#x2F;api&#x2F;order&#39;, {      method: &#39;POST&#39;,      headers: { &#39;Content-Type&#39;: &#39;application&#x2F;json&#39; },      credentials: &#39;include&#39;,      body: JSON.stringify(getRandomOrder())    })    count++  }}</code></pre><p><code>src/random-lib.js</code>中存放的是生成随机订单的代码。订单包含以下四个部分：</p><ul><li>username</li><li>orderlist(用户点的餐)</li><li>price</li><li>position(用户当前所在位置)</li></ul><h2 id="3-后端"><a href="#3-后端" class="headerlink" title="3. 后端"></a>3. 后端</h2><h3 id="3-1-监听：来自前端的订单信息"><a href="#3-1-监听：来自前端的订单信息" class="headerlink" title="3.1  监听：来自前端的订单信息"></a>3.1  监听：来自前端的订单信息</h3><p>后端使用的HTTP框架是<a href="https://github.com/gofiber/fiber">fiber</a>。接收到前端的订单信息后，调用<code>utilities.GenSnowFlakeID</code>为每个订单生成一个唯一的ID，并将其存入数据库中。</p><p><strong>监听部分：</strong></p><pre><code>app :&#x3D; fiber.New()app.Use(cors.New(cors.Config{AllowCredentials: true,}))app.Post(&quot;&#x2F;api&#x2F;order&quot;, controllers.OrderLogger)app.Listen(&quot;:8000&quot;)</code></pre><p><strong>Handler:</strong></p><pre><code>func OrderLogger(c *fiber.Ctx) error {var data map[string]stringif err :&#x3D; c.BodyParser(&amp;data); err !&#x3D; nil {return err}order :&#x3D; models.Order{ID:        utilities.GenSnowFlakeID(),Username:  data[&quot;username&quot;],OrderList: data[&quot;orderlist&quot;],Price:     data[&quot;price&quot;],Position:  data[&quot;position&quot;],}log.Printf(&quot;\033[1;33m*Receiced a food order, \033[1;34mID: %d\033[0m %s&quot;, order.ID, order.String())database.DB.Create(&amp;order)return c.JSON(order)}</code></pre><h3 id="3-2-处理订单"><a href="#3-2-处理订单" class="headerlink" title="3.2  处理订单"></a>3.2  处理订单</h3><p>当后端拿到一个订单后，我们要做的事情就是要从数据库中选出一个外卖员，并将这个订单分配给他。分配的算法比较简单，只需要找到离订单产生位置最近的外卖员即可。</p><p>首先我们遇到一个问题：数据库中的外卖员数量那么多，我们如何迅速找出距离最近的外卖员？</p><p>一个非常简单但是实际不可行的方案是把数据库的所有外卖员都加载到一个数组中，然后遍历这个数组，找到符合条件的外卖员。但是当外卖员数量非常大的时候，这个方案明显不可行。我采用的办法受到Uber的启发，将整个地图分成多个片区(我用的地图是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="9.553ex" height="1.557ex" role="img" focusable="false" viewBox="0 -666 4222.4 688" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-1-TEX-N-30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path><path id="MJX-1-TEX-N-D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><use data-c="31" xlink:href="#MJX-1-TEX-N-31"></use><use data-c="30" xlink:href="#MJX-1-TEX-N-30" transform="translate(500,0)"></use><use data-c="30" xlink:href="#MJX-1-TEX-N-30" transform="translate(1000,0)"></use></g><g data-mml-node="mo" transform="translate(1722.2,0)"><use data-c="D7" xlink:href="#MJX-1-TEX-N-D7"></use></g><g data-mml-node="mn" transform="translate(2722.4,0)"><use data-c="31" xlink:href="#MJX-1-TEX-N-31"></use><use data-c="30" xlink:href="#MJX-1-TEX-N-30" transform="translate(500,0)"></use><use data-c="30" xlink:href="#MJX-1-TEX-N-30" transform="translate(1000,0)"></use></g></g></g></svg></mjx-container>，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="7.291ex" height="1.557ex" role="img" focusable="false" viewBox="0 -666 3222.4 688" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path id="MJX-1-TEX-N-30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path><path id="MJX-1-TEX-N-D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><use data-c="32" xlink:href="#MJX-1-TEX-N-32"></use><use data-c="30" xlink:href="#MJX-1-TEX-N-30" transform="translate(500,0)"></use></g><g data-mml-node="mo" transform="translate(1222.2,0)"><use data-c="D7" xlink:href="#MJX-1-TEX-N-D7"></use></g><g data-mml-node="mn" transform="translate(2222.4,0)"><use data-c="32" xlink:href="#MJX-1-TEX-N-32"></use><use data-c="30" xlink:href="#MJX-1-TEX-N-30" transform="translate(500,0)"></use></g></g></g></svg></mjx-container>一个街区，共25个块)，每接到一个订单时，就根据订单的位置确定分区的ID，在指定的分区中寻找与其距离最近的且闲暇的外卖员。</p><pre><code>&#x2F;&#x2F; currently we suppose that we can find available couriers in each block&#x2F;&#x2F; TODO: deal with the case that there is no couriers in certain blockvar couriers []models.Courierdatabase.DB.Find(&amp;couriers, &quot;block_id &#x3D; ?&quot;, userBlockID)var selectedCourier models.Courier &#x3D; couriers[0]&#x2F;&#x2F; TODO: the credit of couriers should also be taken into consideration&#x2F;&#x2F; when selecting couriersfor _, courier :&#x3D; range couriers {isDistShorter :&#x3D; calcDist(order.Position, courier.Position) &lt; calcDist(order.Position, selectedCourier.Position)if courier.IsAvailable &amp;&amp; isDistShorter {selectedCourier &#x3D; courier}}</code></pre><p>之后外卖员处于忙碌状态，位置会不断的改变(但我们只能在后端模拟其位置的改变)。其位置改变的同时，分区的ID也可能会发生变化，所以需要不停的对外卖员的信息进行更新。此处我们假定外卖员只会走直角路线。</p><pre><code>&#x2F;&#x2F; Since we have selected this courier, this courier is&#x2F;&#x2F; no longer availabledatabase.DB.Model(&amp;models.Courier{}).Where(&quot;name &#x3D; ?&quot;, selectedCourier.Name).Update(&quot;is_available&quot;, 0)&#x2F;&#x2F; When the server has selected the courier,&#x2F;&#x2F; the courier then need to go to the position of user&#x2F;&#x2F; In fact, the courier need to go to the position of restaurant,&#x2F;&#x2F; then go to the position of user,&#x2F;&#x2F; but for simplicity, now we omit the factor of restaurantcurrentPos :&#x3D; selectedCourier.Positionfor currentPos !&#x3D; order.Position {updatePosition(&amp;currentPos, order.Position)database.DB.Model(&amp;models.Courier{}).Where(&quot;name &#x3D; ?&quot;, selectedCourier.Name).Update(&quot;position&quot;, currentPos)database.DB.Model(&amp;models.Courier{}).Where(&quot;name &#x3D; ?&quot;, selectedCourier.Name).Update(&quot;block_id&quot;, mapPosToBlockID(currentPos))time.Sleep(time.Millisecond * 250)}&#x2F;&#x2F; The current order finished. The selected courier is also free nowdatabase.DB.Model(&amp;models.Courier{}).Where(&quot;name &#x3D; ?&quot;, selectedCourier.Name).Update(&quot;is_available&quot;, 1)log.Printf(&quot;\033[1;32mOrder processed. \033[1;34mID: %d.\033[0m&quot;, order.ID)</code></pre><h3 id="3-3-并发：提高效率"><a href="#3-3-并发：提高效率" class="headerlink" title="3.3  并发：提高效率"></a>3.3  并发：提高效率</h3><p>Go语言在语言层面上为并发提供了支持，这也是为什么这个项目的后端选择Go语言。</p><p>在这个项目中，我使用了生产者-消费者的同步模型。创建了4个goroutine从数据库中取出订单，放到buffer中(使用Go语言的Channel实现)，并创建32个goroutine从buffer中取出订单，进行处理。</p><pre><code>func RunProcessOrderTask() {for i :&#x3D; 0; i &lt; 4; i++ {wg.Add(1)go getOrder()}for i :&#x3D; 0; i &lt; 32; i++ {wg.Add(1)go processOrder()}wg.Wait()}</code></pre><p>从数据库取出订单的4个goroutine在取订单时会发生数据竞争(取出订单包含两个操作：获得订单和删除订单，如果不加保护，那么可能导致buffer中出现两个相同的订单)，所以要加一把互斥锁：</p><pre><code>var orderChannel &#x3D; make(chan models.Order, 64)var wg sync.WaitGroupvar mutex sync.Mutexfor {&#x2F;&#x2F; Take a order from the database, then put it into the channel&#x2F;&#x2F; When there is no order in the database, then wait&#x2F;&#x2F; Do remember to delete it from the databasemutex.Lock()var order models.Orderif database.DB.First(&amp;order).Error !&#x3D; nil {mutex.Unlock()continue}orderChannel &lt;- orderdatabase.DB.Model(&amp;models.Order{}).Where(&quot;id &#x3D; ?&quot;, order.ID).Delete(&amp;order)mutex.Unlock()}</code></pre><h2 id="4-运行效果"><a href="#4-运行效果" class="headerlink" title="4. 运行效果"></a>4. 运行效果</h2><p><strong>前端：</strong></p><p><img src="https://raw.githubusercontent.com/TimeSea05/food-order-distr-sim/master/img/frontend.png" alt="frontend.png"></p><p><strong>后端：</strong></p><p><img src="https://raw.githubusercontent.com/TimeSea05/food-order-distr-sim/master/img/backend.png" alt="frontend.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;仓库地址: &lt;a href=&quot;https://github.com/TimeSea05/food-order-distr-sim&quot;&gt;https://github.com/TimeSea05/food-order-distr-sim&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个项目是尤老师在大</summary>
      
    
    
    
    
  </entry>
  
</feed>
